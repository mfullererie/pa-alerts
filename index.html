<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PA Weather Watches & Warnings</title>

  <style>
    table {
      border-collapse: collapse;
      width: 100%;
      max-width: 1200px;
    }

    th, td {
      padding: 6px;
      border: 1px solid #333;
      vertical-align: top;
    }

    th {
      background: #f0f0f0;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 6px;
    }

    .refresh-label {
      font-size: 0.95em;
      color: #333;
    }

    /* Type cell styling */
    .type-cell {
      font-weight: 600;
      color: #111;
    }

    .type-watch {
      background-color: rgba(255, 165, 0, 0.5); /* orange */
    }

    .type-warning {
      background-color: rgba(220, 38, 38, 0.5); /* red */
    }
  </style>
</head>
<body>
  <h1>PA Weather Watches & Warnings</h1>

  <div class="controls">
    <span class="refresh-label">Auto-refresh: every 5 minutes</span>
    <button id="refreshBtn">Refresh Now</button>
  </div>

  <p id="status">Loading alerts…</p>

  <div id="tableContainer"></div>

  <h2 style="margin-top: 18px;">Alert Map</h2>
  <img
    id="wwaMap"
    src="https://www.weather.gov/images/crh/noc/wwa_pa.png"
    alt="NWS Current Watches, Warnings, and Advisories (PA)"
    style="max-width: 1200px; width: 100%; height: auto; border: 1px solid #ccc;"
  />
  <p style="margin-top: 6px; font-size: 0.95em;">
    Map source:
    <a href="https://www.weather.gov/images/crh/noc/wwa_pa.png" target="_blank" rel="noopener noreferrer">
      NWS Current Watches, Warnings, and Advisories (PA)
    </a>
  </p>

  <script>
    const API_URL = "https://api.weather.gov/alerts/active?area=PA";
    const MAP_URL = "https://www.weather.gov/images/crh/noc/wwa_pa.png";

    const zoneCache = new Map();

    function formatTime(val) {
      if (val === null || val === undefined) return "N/A";
      const d = new Date(val);
      return isNaN(d) ? String(val) : d.toLocaleString();
    }

    function isWatchOrWarning(p) {
      const e = (p.event || "").toLowerCase();
      return (
        (e.includes("watch") || e.includes("warning") || e.includes("emergency")) &&
        !e.includes("advisory") &&
        !e.includes("statement") &&
        !e.includes("outlook") &&
        !e.includes("test")
      );
    }

    function getExpiresMs(p) {
      const raw = p.ends || p.expires;
      if (!raw) return null;
      const ms = new Date(raw).getTime();
      return isNaN(ms) ? null : ms;
    }

    async function fetchWithTimeout(url, options = {}, timeoutMs = 8000) {
      const controller = new AbortController();
      const id = setTimeout(() => controller.abort(), timeoutMs);
      try {
        return await fetch(url, { ...options, signal: controller.signal });
      } finally {
        clearTimeout(id);
      }
    }

    async function getZoneInfo(zoneUrl) {
      if (zoneCache.has(zoneUrl)) return zoneCache.get(zoneUrl);
      try {
        const r = await fetchWithTimeout(
          zoneUrl,
          { headers: { Accept: "application/geo+json" } },
          5000
        );
        if (!r.ok) throw new Error("HTTP " + r.status);
        const d = await r.json();
        const info = { name: d?.properties?.name || zoneUrl, state: d?.properties?.state || null };
        zoneCache.set(zoneUrl, info);
        return info;
      } catch {
        return { name: zoneUrl, state: null };
      }
    }

    async function getPALocationsFromAffectedZones(p) {
      const zones = Array.isArray(p.affectedZones) ? p.affectedZones : [];
      if (!zones.length) return { paNames: [], hasPA: false };

      const settled = await Promise.allSettled(zones.map(getZoneInfo));
      const names = settled
        .filter(r => r.status === "fulfilled" && r.value && r.value.state === "PA")
        .map(r => r.value.name);

      // Dedup but keep only PA zones
      const unique = [...new Set(names)];
      return { paNames: unique, hasPA: unique.length > 0 };
    }

    function groupAlerts(list) {
      const map = new Map();
      for (const a of list) {
        const key = `${a.event}||${a.expiresMs}`;
        if (!map.has(key)) {
          map.set(key, { event: a.event, expiresMs: a.expiresMs, locations: new Set() });
        }
        a.paNames.forEach(l => map.get(key).locations.add(l));
      }
      return [...map.values()].sort((a, b) => (a.expiresMs ?? 1e15) - (b.expiresMs ?? 1e15));
    }

    function getTypeClass(event) {
      return event.toLowerCase().includes("watch") ? "type-watch" : "type-warning";
    }

    // NEW: Sort by base name ignoring directional prefixes, but keep display text unchanged.
    function locationSortKey(name) {
      if (!name) return "";
      return name
        .trim()
        .replace(
          /^(north|south|east|west|northeast|northwest|southeast|southwest)\s+/i,
          ""
        )
        .trim()
        .toLowerCase();
    }

    function renderTable(grouped) {
      const c = document.getElementById("tableContainer");
      if (!grouped.length) {
        c.innerHTML = "<p>No active watches or warnings for PA.</p>";
        return;
      }

      c.innerHTML = `
        <table>
          <thead>
            <tr>
              <th>Type</th>
              <th>Locations</th>
              <th>Expires</th>
            </tr>
          </thead>
          <tbody>
            ${grouped.map(g => {
              const sortedLocations = [...g.locations].sort((a, b) => {
                const ka = locationSortKey(a);
                const kb = locationSortKey(b);
                const primary = ka.localeCompare(kb);
                // Tie-breaker: if both reduce to the same base name, keep a stable readable order
                return primary !== 0 ? primary : a.localeCompare(b);
              }).join("; ");

              return `
                <tr>
                  <td class="type-cell ${getTypeClass(g.event)}">${g.event}</td>
                  <td>${sortedLocations}</td>
                  <td>${formatTime(g.expiresMs)}</td>
                </tr>
              `;
            }).join("")}
          </tbody>
        </table>
      `;
    }

    function refreshMapImage() {
      const img = document.getElementById("wwaMap");
      if (img) img.src = MAP_URL + "?t=" + Date.now();
    }

    async function fetchAlerts() {
      const status = document.getElementById("status");
      const btn = document.getElementById("refreshBtn");
      btn.disabled = true;
      status.textContent = "Loading alerts…";

      try {
        const r = await fetchWithTimeout(
          API_URL,
          { headers: { Accept: "application/geo+json" } },
          8000
        );
        if (!r.ok) throw new Error("HTTP " + r.status);
        const d = await r.json();

        const ww = (d.features || []).filter(f => f?.properties && isWatchOrWarning(f.properties));

        const settled = await Promise.allSettled(ww.map(async f => {
          const p = f.properties;
          const pa = await getPALocationsFromAffectedZones(p);
          return { event: p.event, expiresMs: getExpiresMs(p), paNames: pa.paNames, hasPA: pa.hasPA };
        }));

        const paOnly = settled
          .filter(x => x.status === "fulfilled" && x.value && x.value.hasPA)
          .map(x => x.value);

        renderTable(groupAlerts(paOnly));

        status.textContent = `Last updated: ${new Date().toLocaleString()} | Alerts: ${paOnly.length}`;
        refreshMapImage();
      } catch (err) {
        console.error(err);
        status.textContent = "Error loading alerts.";
        document.getElementById("tableContainer").innerHTML = "<p>Error loading alerts.</p>";
        refreshMapImage();
      } finally {
        btn.disabled = false;
      }
    }

    document.getElementById("refreshBtn").addEventListener("click", fetchAlerts);
    fetchAlerts();
    setInterval(fetchAlerts, 5 * 60 * 1000);
  </script>
</body>
</html>